@page "/"
@using System;
@using System.ComponentModel.DataAnnotations;
@using System.Collections.Concurrent;
@using Grpc.Core;
@using Grpc.Net.Client;
@using PerfRunner.V1;
@using PerfLoader.Helper;
@using Polly;
@using Polly.Registry;
@using Polly.Retry;
@using Polly.CircuitBreaker;
@inject IReadOnlyPolicyRegistry<string> PollyPolicyRegistry
@inject IConfiguration Configuration
@inject ILogger<Index> Logger

<PageTitle>Index</PageTitle>
<environment include="Development">
    <div>Environment is Development</div>
</environment>
<!-- environment exclude="Development">
    <div>Environment is NOT Development</div>
</environment>
<environment include="Staging,Development,Staging_2">
    <div>Environment is: Staging, Development or Staging_2</div>
</environment -->

<h1>Hello, world!</h1>

Welcome to Perf Loader.

<SurveyPrompt Title="How is Blazor working for you?" />
<br>

<EditForm Model="@TestRequest">
<InputSelect @bind-Value=SelectedChannels>
@foreach(var channel in _perfChannels)
{
 <option value="@channel.Target">@channel.Target</option>
}
 </InputSelect>
<br>
    <InputText @bind-Value=TestRequest.Name></InputText>

    <InputNumber @bind-Value=TestRequest.Rate></InputNumber>


Actions: 
@foreach (var item in TestRequest.Actions)
{
    <br>
    <label>Name: @item.Name</label>
    <label>Rate: @item.Rate</label>
}
<br>
 <InputText @bind-Value=TestRequest.Actions.Last().Name></InputText>
 <InputNumber @bind-Value=TestRequest.Actions.Last().Rate></InputNumber>   
 <InputSelect @bind-Value=TestRequest.Actions.Last().LoadDistribution>
 <option value="@LoadDistribution.Even">Even</option>
 <option value="@LoadDistribution.Uneven">Uneven</option>
 </InputSelect>   
 <!-- InputDate @bind-Value=TestRequest.Actions.Last().Duration></InputDate -->
 <button @onclick="() => TestRequest.Actions.Add(TestRequest.Actions.Last())">+</button>   
 <button @onclick="() => TestRequest.Actions.RemoveAt(TestRequest.Actions.Count - 1)">-</button>
 <button @onclick="() => StartTestAsync()">Start Test</button>

 <button @onclick="() => StopAllTestsAsync()">Stop All Tests</button>
</EditForm>

Running Tests:
@foreach (var item in RunningTests)
{
 <br>
 <label>@item.Guid</label>
 <button @onclick="() => StopTest(item.Guid)">Stop</button>
}
<br>
<br>

@foreach (var item in RunningTests)
{
    <CascadingValue Value="@this">
        <MonitorTest TestRequest=item />
    </CascadingValue>
}
<br>
<button @onclick="() => CheckTests()">CheckTests</button>
 <br>
 <button @onclick="() => MonitorAllTestsAsync()">MonitorAllTests</button>

@code {

    public class PerfClientChannels_
    {
        public string[] SelectedChannels { get; set; } = new string[] { "All" };
    }

    private static ConcurrentBag<GrpcChannel> _perfChannels = new ConcurrentBag<GrpcChannel>();

    private static ConcurrentBag<GrpcChannel> _perfIdleChannels = new ConcurrentBag<GrpcChannel>();

    private AsyncCircuitBreakerPolicy _circuitBreakerPolicy;

    private static object _updateChannelsLock = new object();

    private static SemaphoreSlim _updateChannelsSemSlim = new SemaphoreSlim(1, 1);

    private static volatile bool _updateChannelsLockFlag;

    private ActionOption _actionOption;

    private UpdateAction _updateAction = new UpdateAction();

    // will not work? [Required, MinLength(1)]
    public string[] SelectedChannels { get; set; } = new string[] { };

    private TestRequest TestRequest { get; set; }

    private CancellationToken _cancellationToken;// = new CancellationToken();

    private static IList<TestRequest> RunningTests { get; set; } = new List<TestRequest>();

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            // on page load only - after Initialized
            Logger.LogDebug("In first render");

            _circuitBreakerPolicy = PollyPolicyRegistry.Get<AsyncCircuitBreakerPolicy>(
            PollyPolicies.GrpcPolicyName);

            // UpdateConnections();
            // Task task = new Task(() => Thread.Sleep(100000));
            // task.Start();
            // Action UpdtConn = Afce;
            // start only once
            // if (!_updateChannelsLockFlag)
            {
                // Task task = new Task(new Action(UpdateConnections));
                // Task task = new Task(new Action(UpdateConnectionsPollyPolicies));
                // Task task = new Task(new Action(UpdateConnectionsPolly));
                // task.Start();
            }
        }

        Task task = new Task(new Action(UpdateConnectionsPolly));
        task.Start();

        Logger.LogDebug("In After render");
        base.OnAfterRender(firstRender);
    }
    protected override void OnInitialized()
    {
        NewTest();

        /*
        actionOption = new ActionOption() { Name = "Login1",
        Rate = 1, Guid = Guid.NewGuid().ToString() };
        testRequest.Actions.Add(actionOption);*/

        // var host_ = "http://localhost:5277";
        // var channel = GrpcChannel.ForAddress(host_);

        _cancellationToken = new CancellationToken();
        // PerfClient = new Perf.PerfClient(channel);
        Logger.LogDebug("Running initialized!");

        // load or update Perf Clients only in beginning*
        if (_perfChannels.Count == 0)
        {
            foreach (var cli in Configuration.GetRequiredSection("PerfRunners").Get<List<string>>())
            {
                var channel = GrpcChannel.ForAddress(cli);

                // if not online
                // if (!channel.State.Equals(ConnectivityState.Idle))
                {
                    // _perfClientChannels_.PerfClientChannels.Add(cli);
                    Logger.LogDebug("Channel {0} was created!", channel.Target);
                    _perfChannels.Add(channel);
                }
            }

            // SelectedChannels = _perfClients.ToArray()
        }

        // if(RunningTests.Count > 0)
        {
            // CheckTests();
        }
    }

    private void Afce()
    {
        do
        {
            Logger.LogDebug("In async call now!");
            Thread.Sleep(10 * 1000);
        }
        while (true);
    }

    private void UpdateConnectionsPollyPolicies()
    {

        // this stops us from making the call if the circuit is open. If we take
        // this out, the ExecuteAsync() method below will throw a BrokenCircuitException
        // on every call, so this is just a performance optimisation:

        if (_circuitBreakerPolicy.CircuitState == CircuitState.Open ||
        _circuitBreakerPolicy.CircuitState == CircuitState.Isolated)
        {
            return;
        }

        foreach (var ch in _perfChannels)
        {
            var perfCli = new Perf.PerfClient(ch);


            // Where the magic happens. ExecuteAsync will handle and then re-raise any
            // exceptions thrown, so we need to catch them here too.
            try
            {
                _circuitBreakerPolicy.ExecuteAsync(
                    () =>
                {
                    Logger.LogError("In polly now!");
                    // var rep = perfCli.Ping(new PingRequest());
                    // throw new PlatformNotSupportedException("Polly_");
                    // Console.WriteLine("Grpc circuit!");

                    perfCli.Ping(new PingRequest());
                    // Some();

                    return new Task(() => Thread.Sleep(0));
                    // return new Task(() => throw new InsufficientMemoryException("Polly"));
                });
                /*
                Func<Task> action = Some;
            void Some()
            { 
                            new Task(perfCli.Ping(new PingRequest()));
                            }
                _circuitBreakerPolicy.ExecuteAsync(() => Some());*/
                /*
                RetryPolicy retryPolicy = Policy.Handle<Exception>()
                    .Retry(3, (exception, retryCount) =>
                    {
                    Console.WriteLine($"{exception.GetType()} thrown, retrying {retryCount}.");
            });

            retryPolicy.Execute(() => perfCli.Ping(new PingRequest()));

            // Console.WriteLine($"Received a response of {result}.");
            */
            }
            catch (Exception e)
            {
                Logger.LogError("Unable to connect to {0}!", ch.Target);
                return;
            }
        }
    }

    private void Some()
    {
        Logger.LogDebug("Throw excpn now!");
        throw new NotImplementedException();
    }

    private async void UpdateConnectionsPolly()
    {
        // lock (_updateChannelsLock)
        // await _updateChannelsSemSlim.WaitAsync();

        try
        {
            // System.Threading.Monitor.Enter(_updateChannelsLock, ref _updateChannelsLockFlag);

            // _updateChannelsLockFlag = true;
            int ts = 3;

            int iIndex = 0;
            Resilience.LoadPolicy(Logger);

           //  do
           // {
                Resilience._watch = new System.Diagnostics.Stopwatch();
                Resilience._watch.Start();

                // try
                {
                    foreach (var ch in _perfChannels)
                    // Parallel.ForEach(_perfChannels, async (ch) => 
                    {
                        var perfCli = new Perf.PerfClient(ch);

                        var policy = Policy.Handle<RpcException>()
                        .WaitAndRetryForever(
                        retryAttempt => TimeSpan.FromSeconds(retryAttempt),
                        (exception, timespan, context) =>
                        {
                            Logger.LogInformation("Trying to connect to {0} again in {1} s.", ch.Target, Math.Pow(2, timespan));
                            Logger.LogInformation("Context is {0}", context);
                        });

                        // var rep = await Resilience.PolicyWrap.ExecuteAsync(ct =>
                        // {
                            var rep = policy.Execute(() =>
                                perfCli.Ping(new PingRequest())
                            );

                            // Logger.LogError("Unable to connect to {0}!", ch.Target);
/*                            Logger.LogDebug("In policy now for " + ch.Target);


                            string some() { return "Resp from server!"; }
                            Func<string> someFunc = some;
                            return new Task<string>(someFunc);

                        }, _cancellationToken);*/

                        Logger.LogDebug("Response : {0} for request# {1} after {2} ms from {3}!", rep.ToString(), iIndex,
                        Resilience._watch.Elapsed.TotalMilliseconds, ch.Target);

                        Resilience._watch.Stop();
                    }
                    // );


                }
                // catch (Exception e) // try-catch not needed, now that we have a Fallback.Handle<Exception>. It's only been left in to *demonstrate * it should never get hit.
                {
                //    Logger.LogDebug("Unable to connect " + e.GetType());
                  /*  throw new InvalidOperationException(
                    "Should never arrive here. Use of fallbackForAnyException should have provided nice fallback value for any exceptions.",
                    e);*/
                }

                // Wait half second
                Task.Delay(TimeSpan.FromSeconds(0.5), _cancellationToken);

                // do every 10s for now
                System.Threading.Thread.Sleep(1000 * ts);

            // } while (iIndex++ < 1200) ;
        }
        finally
        {
            if(_updateChannelsLockFlag)
            {
                // System.Threading.Monitor.Exit(_updateChannelsLock);
            }

            // _updateChannelsSemSlim.Release();
        }
    }


    private void UpdateConnections()
    {
        lock (_updateChannelsLock)
        {

            _updateChannelsLockFlag = true;

            do
            {
                ConcurrentBag<GrpcChannel> allChannels = new ConcurrentBag<GrpcChannel>();
                int ts = 3;

                foreach (var ele in _perfIdleChannels)
                {
                    allChannels.Add(ele);
                }

                foreach (var ele in _perfChannels)
                {
                    allChannels.Add(ele);
                }

                foreach (var ch in allChannels)
                {
                    var perfCli = new Perf.PerfClient(ch);

                    try
                    {
                        var rep = perfCli.Ping(new PingRequest());
                        var ch_ = ch;

                        // add if not exists
                        if (!_perfChannels.Contains(ch_))
                        {
                            _perfChannels.Add(ch);
                        }

                        // ch_ = ch;
                        if (_perfIdleChannels.Contains(ch_))
                        {
                            // _perfIdleChannels.TryTake(out var ch2);
                            _perfIdleChannels.RemoveItem(ch_);
                        }
                    }
                    catch (RpcException ex)
                    {
                        Logger.LogError("Unable to connect to {0}!, Retry in {1}s", ch.Target, ts);
                        var ch_ = ch;

                        // add if not exists
                        if (!_perfIdleChannels.Contains(ch_))
                        {
                            _perfIdleChannels.Add(ch);
                        }

                        // ch_ = ch;
                        if (_perfChannels.Contains(ch_))
                        {
                            // _perfChannels.TryTake(out var ch3);
                            _perfChannels.RemoveItem(ch_);
                        }
                    }
                }

                // StateHasChanged();

                // do every 10s for now
                System.Threading.Thread.Sleep(1000 * ts);

            } while (true);
        }
    }

    public class UpdateAction
    {
        public ActionOption ActionOption { get; set; }

        public string TestGuid { get; set; }
    }

    public async Task HandleUpdateAction(string actionGuid, ActionOptionUpdated actionOptionUpdated, string testGuid,
    EventArgs e)
    // private async Task HandleUpdateAction(EditContext editContext)
    {
        // var testGuid = "test";

        try
        {
            // Logger.LogInformation("Updating test " + _updateAction.TestGuid);
            if (e is ChangeEventArgs ce)
            {
                Logger.LogInformation("Updating action " + actionGuid);

                // var action = (UpdateAction)editContext.Model;
                var updateAction = new UpdateActionRequest()
                    {
                        // Guid = action.TestGuid,
                        TestGuid = testGuid,
                        // TestGuid = _updateAction.TestGuid,
                        ActionGuid = actionGuid,
                        ActionOptionUpdate = actionOptionUpdated,
                        UpdateValue = (string)ce.Value.ToString()
                    };

                void UpdateAction(GrpcChannel? cli)
                {

                    var perfCli = new Perf.PerfClient(cli);
                    var rep = perfCli.UpdateActionAsync(updateAction);
                }

                // not wait for task to complete
                foreach (var cli in _perfChannels)
                {
                    // if no selection, run in all
                    if (SelectedChannels.Length > 0)
                    {
                        Parallel.ForEach(SelectedChannels, (item) =>
                        {

                            // check only if any sel made
                            if (item.Contains(cli.Target))
                            {
                                // if(cli.)
                                UpdateAction(cli);
                            }
                        });
                    }
                    else
                    {
                        UpdateAction(cli);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError("Update action failed " + ex.Message);
        }
    }

    private void NewTest()
    {

        TestRequest = new TestRequest()
            {
                Name = "Test Name",
                Guid = Guid.NewGuid().ToString(),
                // Duration = Google.Protobuf.WellKnownTypes.Duration.FromTimeSpan(TimeSpan.FromSeconds(10))
                Rate = 3,
            };

        _actionOption = new ActionOption()
            {
                Name = "Login",
                Rate = 6,
                // Duration = Google.Protobuf.WellKnownTypes.Duration.FromTimeSpan(TimeSpan.FromSeconds(10)),
                // Duration = Google.Protobuf.WellKnownTypes.Duration.FromTimeSpan(TimeSpan.MaxValue),
                Guid = Guid.NewGuid().ToString(),
            };

        // Logger.LogInformation("Action " + _actionOption.Guid);

        TestRequest.Actions.Add(_actionOption);
        _updateAction.ActionOption ??= _actionOption;

        _actionOption = new ActionOption()
            {
                Name = "PlayBowling",
                Rate = 3,
                // Duration = Google.Protobuf.WellKnownTypes.Duration.FromTimeSpan(TimeSpan.FromSeconds(16)),
                // Duration = Google.Protobuf.WellKnownTypes.Duration.FromTimeSpan(TimeSpan.MaxValue),
                Guid = Guid.NewGuid().ToString()
            };

        // Logger.LogInformation("Action " + _actionOption.Guid);

        TestRequest.Actions.Add(_actionOption);

        _updateAction.ActionOption ??= _actionOption;
        _updateAction.TestGuid ??= TestRequest.Guid;

        /*
        actionOption = new ActionOption()
        {
        Name = "LoginGrpc",
        Rate = 3,
        Guid = Guid.NewGuid().ToString()
        };
        TestRequest.Actions.Add(actionOption);*/
    }

    private async void StartTestAsync()
    {
        Logger.LogInformation("Starting test " + TestRequest.Guid);

        // not wait for task to complete
        // var rep = PerfClient.RunTestAsync(TestRequest);
        foreach (var cli in _perfChannels)
        {
            void RunTest()
            {
                TestRequest.Clients.Add(cli.Target);
                var perfCli = new Perf.PerfClient(cli);
                var rep = perfCli.RunTestAsync(TestRequest);
            }

            // if no selection, run in all
            if (SelectedChannels.Length > 0)
            {
                Parallel.ForEach(SelectedChannels, (item) =>
                {
                    // check only if any sel made
                    if (item.Contains(cli.Target))
                    {
                        RunTest();
                    }
                });
            }
            else
            {
                RunTest();
            }
        }

        RunningTests.Add(TestRequest);

        NewTest();
    }

    public void StopTest(string guid)
    {

        Logger.LogInformation("Stopping test " + guid);

        // var rep = PerfClient.StopTestAsync(new StopTestRequest { Guid = guid });
        foreach (var cli in _perfChannels)
        {
            void StopTest()
            {
                var perfCli = new Perf.PerfClient(cli);
                var rep = perfCli.StopTestAsync(new StopTestRequest { Guid = guid });
            }

            // if no selection, run in all
            if (SelectedChannels.Length > 0)
            {
                Parallel.ForEach(SelectedChannels, (item) =>
                {

                    // check only if any sel made
                    if (item.Contains(cli.Target))
                    {
                        StopTest();
                    }
                });
            }
            else
            {
                StopTest();
            }
        }

        // StateHasChanged();
        // RunningTests.Remove(test => test.Guid.Equals(guid));
        RunningTests.Remove(RunningTests.Where(test => test.Guid.Equals(guid)).First());

        StateHasChanged();

        // CheckTests();
    }

    private async void StopAllTestsAsync()
    {
        foreach (var cli in _perfChannels)
        {
            foreach (var item_ in RunningTests)
            {
                Logger.LogInformation("Stopping test " + item_.Guid);

                void StopAllTests()
                {
                    var perfCli = new Perf.PerfClient(cli);
                    var rep = perfCli.StopTestAsync(new StopTestRequest { Guid = item_.Guid });
                }

                // not wait for task to complete
                // var rep = PerfClient.StopTestAsync(new StopTestRequest { Guid = item.Guid });
                // RunningTests.Remove(item);
                // if no selection, run in all
                if (SelectedChannels.Length > 0)
                {
                    Parallel.ForEach(SelectedChannels, (item) =>
                    {
                        // check only if any sel made
                        if (item.Contains(cli.Target))
                        {
                            StopAllTests();
                        }
                    });
                }
                else
                {
                    StopAllTests();
                }
            }
        }

        RunningTests.Clear();
    }

    private void CheckTests()
    {
        RunningTests.Clear();

        foreach (var cli in _perfChannels)
        {
            // if no selection, run in all
            if (SelectedChannels.Length > 0)
            {

                Parallel.ForEach(SelectedChannels, (item) =>
                {
                    // check only if any sel made
                    if (item.Contains(cli.Target))
                    {
                        RunningTests_();
                    }
                });
            }
            else
            {
                RunningTests_();
            }

            void RunningTests_()
            {
                try
                {
                    // var res = PerfClient.RunningTests(new RunningTestsRequest());
                    var perfCli = new Perf.PerfClient(cli);
                    var res = perfCli.RunningTests(new RunningTestsRequest());

                    foreach (var test in res.Tests)
                    {
                        if (RunningTests.Count > 0)
                        {
                            if (!RunningTests.Select(item => item.Guid.Equals(test.Guid)).First())
                            {
                                RunningTests.Add(test);
                            }
                        }
                        else
                        {
                            RunningTests.Add(test);
                        }
                    }
                }
                catch (Grpc.Core.RpcException exc)
                {
                    Logger.LogError($"Unable to fetch tests - {exc.Message}");

                    // if unavail remove them? causing exc
                    // _perfClients.Remove(cli);
                }
            }
        }
    }

    private async void MonitorAllTestsAsync()
    {
        var cancelToken = new CancellationTokenSource();

        Parallel.ForEach(_perfChannels, async cli => EachCli(cli));

        async void EachCli(GrpcChannel cli)
        {
            Parallel.ForEach(RunningTests, async item => MonitorParallel(item));

            async void MonitorParallel(TestRequest item)
            {
                Logger.LogInformation("Monitoring test " + item.Guid);

                async void MonitorTests_()
                {

                    try
                    {
                        // not wait for task to complete
                        var perfCli = new Perf.PerfClient(cli);
                        using var resp = perfCli.MonitorTest(new MonitorTestRequest { Guid = item.Guid }, cancellationToken: cancelToken.Token);

                        await foreach (var item1 in resp.ResponseStream.ReadAllAsync(cancelToken.Token))
                        {
                            var resp_ = item1;
                            Logger.LogInformation($"Test is {item1.Name} .");
                            // state?.Invoke();
                            StateHasChanged();
                            // cancelToken.Cancel();
                        }

                    }
                    catch (InvalidOperationException ex)
                    {
                        Logger.LogDebug($"Monitor failed for test {item.Name} with {ex.Message}.");
                        // RunningTests.Remove(item);
                        item = null;
                    }
                    catch (System.Exception ex)
                    {
                        Logger.LogDebug($"Monitor failed for test {item.Name} with {ex.Message}.");
                        // RunningTests.Remove(item);
                        item = null;
                        // throw;
                    }
                    finally
                    {
                        // RunningTests.Remove(item);
                    }
                }

                // if no selection, run in all
                if (SelectedChannels.Length > 0)
                {

                    Parallel.ForEach(SelectedChannels, (item0) =>
                    {
                        // check only if any sel made
                        if (item0.Contains(cli.Target))
                        {
                            MonitorTests_();
                        }
                    });
                }
                else
                {
                    MonitorTests_();
                }

            }
        }

        // RunningTests.Clear();
        foreach (var ele in RunningTests)
        {
            if (ele is null)
            {
                RunningTests.Remove(ele);
            }
        }

        StateHasChanged();
    }
}